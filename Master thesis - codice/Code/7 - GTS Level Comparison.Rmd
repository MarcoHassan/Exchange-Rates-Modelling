---
title: "R Notebook"
output: html_notebook
---

=========
Libraries
=========

```{r}
## Import self defined functions
source("0 - functions.R") ## for this section especially important is the SPA function that returns the bootstrapped interval for the superior preddiction ability hypothesis.

## To handle xts times series objects.
library(xts)

## To extract and plot Cointegration Common Trend
library(CommonTrend)

```

===========
Import Data
===========
```{r}
path <- "/Users/Marco Hassan/Exchange-Rates-Modelling/Master thesis - codice/Written\ Data/level_GTS_pred.csv"

data <- read.csv(path)

data <- as.xts(data[,-1], order.by = as.Date(data[,1]))
```


Plot the different out of sample forecasting fits
```{r}
for(jCountry in c("CH", "JP", "UK"))
{
  print(plot(tail(data[,paste0("EX_", jCountry, "US")], 50), ylab="Rates", 
     main="Linear Estimators - 1 Lag Out of Sample",
     grid.col = NA, col = 1))
  print(lines(data[,paste0("rwPred1_", jCountry, "US")],col= 2, lwd = 2))
  print(lines(data[,paste0("strPred1_", jCountry, "US")], col = "orange", lwd = 2))
  print(lines(data[,paste0("varPred1_", jCountry, "US")], col = "yellow", lwd = 2))
  print(lines(data[,paste0("vecmPred1_", jCountry, "US")], col = "salmon", lwd = 2))
  print(lines(data[,paste0("GTSPred1_", jCountry, "US")], col = "violet", lwd = 2))
  print(addLegend("bottomleft", on=1, 
            legend.names = c("Original", "RW", "ARIMAX", "VAR", "VECM", "GTS"), 
            lty=c(1, 1), lwd=c(2, 1),
            col=c(1, 2, "orange", "yellow", "salmon", "violet"))) 
}

```


** Step 2 - Quantitative Measure for Prediction Power **

Root Mean Squared Error (MSE)
```{r}
rmseFun <- 
          function(error)
          {
            #error <- Actual - Forecast
            #print(error)
            return( sqrt(sum(error**2)/length(error)) )
          }
```

Mean Absolute Error (MAE)
```{r}
maeFun <- 
            function(error)
            {
              #return( Actual - Forecast )
              return( sum(abs(error))/length(error) )
            }
```

Directional Accuracy (DAC)
```{r}
dacFun <- 
          function(Actual, Forecast, LAG)
          {
            return( mean ( sign( diff(Actual, lag=LAG) ) == 
                           sign( diff(Forecast, lag=LAG) ),
                           na.rm = T
                          ) 
                  )
          }
```


Create Series of Forcasting Errors; repeat for all of the lags.
```{r}

# number rolling prediction per forecasting time frame
for(iLag in c(1,3,6,12))
{
assign(paste0("numprediction", iLag), sum(
                                          !is.na(
                                                  data[, 
                                                      paste0("rwPred", iLag, "_JPUS")
                                                      ]
                                                 )
                                          )
       )
  
}

RMSE <- matrix(NA,5,3, 
               dimnames = list( c("rw", "str", "var", "vecm", "GTS"),
               c("CH", "JP", "UK") )
               )

MAE <- matrix(NA,5,3, 
               dimnames = list( c("rw", "str", "var", "vecm", "GTS"),
               c("CH", "JP", "UK") )
               )

DAC <- matrix(NA,5,3, 
               dimnames = list( c("rw", "str", "var", "vecm", "GTS"),
               c("CH", "JP", "UK") )
               )
```


Compute root mean square error and mean absolute error for the different lags and linear estimators
```{r}
errorFun <- 
            function(LAG)
            {
              iRow = 0
              jCol = 1
              for( country in c("CH", "JP", "UK") )
              {
                for( method in c("rw", "str", "var", "vecm", "GTS") )
                {
                  iRow = iRow + 1
                  
                  actual_data <- tail(data[, paste0("EX_", country, "US")],
                                      evalue(paste0("numprediction", LAG))
                                      )
                  
                  forecast_data <- na.trim(data[, paste0(method, 
                                                "Pred", LAG,"_", 
                                                country, "US")
                                               ]
                                           )
                  
                  error_data <- actual_data - forecast_data
                  
                  RMSE[iRow, jCol] <- rmseFun(error_data)
                  
                  MAE[iRow, jCol] <- maeFun(error_data)
                  
                  DAC[iRow, jCol] <- dacFun(actual_data, forecast_data, LAG)
                  
                  if(iRow %% 5 == 0)
                  {
                    jCol = jCol + 1
                    iRow = 0
                  }
                
                }
              }
              
              print(paste("RMSE", LAG))
              print(RMSE)
              cat("\n")
              
              print(paste("MAE", LAG))    
              print(MAE)
              cat("\n")
              
              print(paste("DAC", LAG))    
              print(DAC)
              cat("\n")
            }
```

Evalue the function for different lags
```{r}
for( iLAG in c(1) )  ##c(1, 3, 6, 12))
errorFun(iLAG)

## Notice Japan at lag 1. Much better estimated via GTS. CH is highly biased by the big error in the one estimation. MAE performs better in this sense.
```

====================
Model Confidence set
====================

Model Confidence set
```{r}
#Create u a matrix with all different univariate predictions: each column, one model prediction
u <- na.trim(cbind(data$rwPred1_CHUS, data$varPred1_CHUS, data$strPred1_CHUS, 
                   data$vecmPred1_CHUS, data$GTSPred1_CHUS))

n<-dim(u)[1]
perf<-matrix(NA,n,5)

## RECALL TO CHANGE ALSO HERE THE COUNTRY WHEN ADAPTING AND DERIVING P-VALUES.
for (j in 1:5)
{
  #perf[,j]<- abs(tail(data$EX_UKUS[-nrow(data)], n)-u[,j]) #MAE 
  perf[,j] <- abs(data$EX_CHUS-u[,j])**2 #MSE
}

#colMeans(perf) ## Perf is a matrix containing for each column the loss function of one forecasting method.
  
for (k in 1:5)
{
  print( paste("Benchmark model", colnames(u[,k]))	)
  d<-rep(0,1000)
  s<-1
  for (i in 1:10) ## iterate 10 times with spa 100 bootstrapped values each. Total = 1000.
  { 
     e<-spa(per=perf,column_benchmark_model=k,
            num_predmodels=5,number_predictions=n,q=0.25,iter=100,periodogram=T)
     d[s:(s+99)]<-e$stat.boos
     s<-s+100
  }
  print(mean((d>e$stat))) ## fraction 
}
```


